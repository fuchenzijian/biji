##### 1、Vue的理解？

###### Vue 是用于构建用户界面的渐进式框架

###### 特征： 

```javascript
1.数据驱动（MVVM）
2.组件化{
    1>降低整个系统的耦合度
    2>方便调试
    3>提高可维护性 
    4>复用性
}
3.指令
Vue跟传统开发的区别
    1.Vue所有的界面事件，都是只去操作数据，jq操作dom
    2.Vue所有界面的变动，都是根据数据自动绑定出来的，jq操作dom
```

###### Vue和react的异同点

```javascript
相同点：
	1.都有组件化思想
    2.都支持服务端渲染
    3.都有虚拟dom
    4.数据驱动视图
    5.支持native的方案
区别：
	1.数据变化的实现原理不同
    2.组件化通信的
    3.diff算法不同
```

##### 2、双向数据绑定的原理

```javascript
Vue 实现 双向数据绑定 主要采用：数据劫持结合“发布-订阅”模式的方式，Vue2通过Object.defineProperty（）的 set 和 get，在数据变动时发布消息给订阅者触发监听。Vue3 用new proxy()
```

##### 3.单页面应用（SPA）的理解

|      区别       |          单页面          |          多页面           |
| :-------------: | :----------------------: | :-----------------------: |
|      组成       | 一个主页面和多个页面片段 |        多个主页面         |
|    刷新方式     |         局部刷新         |         整页刷新          |
|     URL模式     |           哈希           |           历史            |
| SEO搜索引擎优化 | 难实现，可用SSR方式改善  |         容易实现          |
|    数据传递     |           容易           | URL、cookie、localStorage |
|    页面切换     |      速度快、体验号      |      速度慢、体验差       |
|      维护       |         相对容易         |         相对复杂          |

###### 优点：

```javascript
1.具有桌面应用的即时性、网站的可移植和可访问性
2.用户体验好、快、内容的改变不需要重新加载整个页面
3.良好的前后端分离，分工更明确
```

###### 缺点：

```javascri
1.不利于搜索引擎的抓取
2.首次渲染速度相对较慢
```

###### 原理：

```javascript
1.监听地址栏中hash变化驱动界面变化
2.用pashsate记录浏览器的历史，驱动界面发送变化
```

###### 如何给SPA做SEO？

```javascript
1.SSR服务端渲染
2.静态化
	1>通过程序将动态页面抓取并保存为静态页面，这样的页面存在于服务器的硬盘中
	2>通过web服务器的URL rewrite的方式
3.使用Phantomjs针对爬虫处理
```

##### v-if与v-show的异同点

|            相同点            |                区别                |
| :--------------------------: | :--------------------------------: |
| 都是控制元素在页面中是否显示 | 1.控制手段  2.编译过程  3.编译条件 |

```javascript
控制手段：v-show隐藏是为该元素添加css样式display:none、dom存在
		v-if如若不符合条件则删除、dom不存在
编译过程：v-if切换有一个局部编译/卸载的过程，
		v-show只切换css样式
编译条件：v-if是真正的条件渲染，只有条件为真的时候渲染，为假时则删除该元素
		v-show不管为真还是假，都渲染，只切换css样式
性能消耗：v-if切换时消耗高 v-show初始时消耗

使用场景：如果需要频繁切换时使用v-show
		如果条件很少改变时使用v-if
```

##### Vue实例挂载

```javascript
1.会触发beforeCreate钩子
2.定义updateComponent渲染页面视图的方法
3.监听组件数据，一旦发生变化，触发beforeUpdate生命钩子
updateComponent方法主要执行在vue初始化声明的render，update方法
render的作用主要是生成VNode
_update主要功能是调用patch，将VNode转化为真是DOM，并且更新到页面中
```

###### 总结

```JavaScript
new Vue 时调用_init方法
	定义$set $get $delete $watch等方法
    定义$on $off $emit 等事件
    定义_update $forceUpdate $destroy 生命周期
调用$mount进行页面的挂载
挂载的时候主要通过mountComponent方法
定义updateComponent更新函数
执行render生成虚拟dom
_update将虚拟DOM生成真实dom结构，并且渲染到页面中
```

##### 生命周期

|   生命周期    |                            描述                            |
| :-----------: | :--------------------------------------------------------: |
| beforeCreate  |                     组件实例被创建之初                     |
|    created    |                     组件实例已完全创建                     |
|  beforeMount  |                         组件挂在前                         |
|    mounted    |                   组件挂载到实例上去之后                   |
| beforeUpdate  |                 组件数据发生变化，更新之前                 |
|    updated    |                        数据更新之后                        |
| beforeDestroy |                      组件实例销毁之前                      |
|   destroyed   | 组件实例销毁之后，页面关闭时，当前页面有很多定时器，并关闭 |

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 |
| created       | 组件初始化完毕，各种数据可以使用，常用于异步数据获取         |
| beforeMount   | 未执行渲染、更新，dom未创建                                  |
| mounted       | 初始化结束，dom已创建，可用于获取访问数据和dom元素           |
| beforeUpdate  | 更新前，可用于获取更新前各种状态                             |
| updated       | 更新后，所有状态已是最新                                     |
| beforeDestroy | 销毁前，可用于一些定时器或订阅的取消                         |

##### 为什么v-if和v-for不建议一起用

###### 优先级

v-for优先级比v-if高

一起用会带来性能方面的浪费

##### SPA首屏加载慢怎么解决？

```javascript
原因
    1.网络然是问题
    2.资源文件体积过大
    3.资源重复发送请求去加载了
    4.加载脚本时，渲染内容堵塞了
解决方案
	1.减小入口体积  eg：路由懒加载  动态加载路由
    2.静态资源本地缓存	eg：合理利用localStorage
    3.UI框架按需加载	
    4.图片资源的压缩	eg：在线字体图标/雪碧图
    5.组件重复打包
    6.开启GZIP压缩
    7.使用SSR
```

##### 为什么data属性是一个函数而不是对象

```javascript

Vue实例的时候定义data属性可以是个对象，也可是个函数
组件中定义data只能是函数
区别
	当data为对象时，组件共用一个内存地址，当一个值改变时，其他也会受到影响
    当data为函数时，每个data内存地址不同，使每个实例对象的数据不会受到其他实例对象数据的污染
结论
    根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
    组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。	采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象
```

##### 如何解决Vue中给对象添加新属性页面不刷新

Vue.set()添加少量新属性     object.assign()大量新属性    $forcecUpdated()不建议用

```javascript
Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。
```

##### 插件与组件的区别

组件(每个.vue都可看做为一个组件)

```javascript
优势
	1.降低耦合度，
    2.调试方便
    3.提高可维护性
```

插件(提供全局功能)

区别

```javascript
编写形式
	组件：编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件
	插件：vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象
注册形式
	组件：vue组件注册主要分为全局注册与局部注册
    插件：插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项
使用场景
	组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue
	插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身
```

##### Vue组件间通信方式有哪些

```javascript
1.通过props传递(场景：父传子 -子组件设置props属性 定义接收父组件传递过来参数 )
2.通过$emit触发自定义事件(场景：子传父 -子组件通过$emit 触发自定义事件，$emit 第二个参数为传递数值)
3.使用ref (复制件在使用子组件的时候设置ref  -父组件通过设置子组件ref来获取数据)
4.EventBus  (场景：兄弟组件传值  -创建一个中央事件总线EventBus  -兄弟组件通过$emit 触发自定事件 -另一个兄弟组件通过$on监听自定义事件 )
5.$parent或$root  (通过共同祖辈$parent / $root 搭建通信侨联)
6.attrs 与listeners  (场景：祖先传递给子孙)
7.Procide 与 lnject 
8.Vuex
适用场景: 复杂关系的组件数据传递
Vuex作用相当于一个用来存储共享变量的容器
state用来存放共享变量的地方
getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值
mutations用来存放修改state的方法。
actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作
小结
- 父子关系的组件数据传递选择 `props` 与 `$emit`进行传递，也可选择`ref`
- 兄弟关系的组件数据传递可选择`$bus`，其次可以选择`$parent`进行传递
- 祖先与后代组件数据传递可选择`attrs`与`listeners`或者 `Provide`与 `Inject`
- 复杂关系的组件数据传递可以通过`vuex`存放共享的变量
```

##### NextTick

```javascript 
定义：
    在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM
    Vue在更新DOM时是异步执行的，当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再进一步更新
    
使用场景：
	在修改数据后立刻得到更新后的DOM结构，可以使用(参数1：回调，参数2：执行函数上下文)
总结：
	1.把回调函数放到callback等待执行
    2.将执行函数放到微任务或宏任务中
    3.事件循环到了微任务或宏任务，执行函数依次执行callback中的回调
```

##### mixin

```javascript
定义：Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以反问mixin类的方法而不必成为自类
使用场景：遇到在不同的组件中要用到一些相同或者相似的代码，这些代码的功能相对独立 这时就可以用Vue中的mixin将代码提取出来 
总结：
	1.替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数
    2.合并型策略是data, 通过set方法进行合并和重新赋值
    3.队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行
    4.叠加型有component、directives、filters，通过原型链进行层层的叠加
```

##### slot

```javascript
v-slot属性只能在<template>上使用，但在只有默认插槽时可以在组件标签上使用
默认插槽名为default，可以省略default直接写v-slot
缩写为#时不能不写参数，写成#default
可以通过解构获取v-slot={user}，还可以重命名v-slot="{user: newName}"和定义默认值v-slot="{user = '默认值'}"
```

##### observable

```javascript
-定义：返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可作为最小化的跨组件状态存储器(Vue2中传入的对象会直接被其变更，他和被返回的对象是同一个   在Vue3中会返回一个可相应的代理，对源对象直接进行变更仍是不可相应的)
-使用场景：在非父子组件通信时使用(用于设置监控属性)

```

##### key

```javascript
-定义：key是给每一个VNode的唯一id。也是diff的一种优化策略，根据key更精准，更快的找到对应节点
-循环时
    如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。
    如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed
-生成时间戳
    当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染
   	-设置key能够大大减少对页面的DOM操作，提高了diff效率
	-建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升
```

##### Keep-alive

```javascript
它是Vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染Dom
```

##### Vue修饰符

```javascript
.stop：阻止事件冒泡
.native：绑定原生事件
.once：事件只执行一次
.self ：将事件绑定在自身身上，相当于阻止事件冒泡
.prevent：阻止默认事件
.caption：用于事件捕获
.once：只触发一次
.keyCode：监听特定键盘按下
.right：右键
```

##### 自定义指令运用场景

```javascript
1.防抖
2.图片懒加载
3.一键copy的功能
```

##### Vue过滤器

```javascript
过滤器：输送介质管道上不可缺少的一种装置(把一些不必要的东西过滤掉)
如何用：大胡子语法和v-band表达式
局部过滤优先于全局过滤被调用
就好比服务端同学给我们返回的字段orderStatus(订单状态),这个字段会返回 1/2/3/4 4种状态；但是我们需要渲染到页面上的是已支付 待发货 已发货  已完成 这个时候，我们可以用到过滤属性 filters;
语法{{状态码 | 方法(将状态码转换成页面展示的字符串)}}277
```

##### 虚拟Dom

```javascript
用普通js对象来描述DOM结构，这个结构就是虚拟DOM; 
js可以操作的那个dom树，就是虚拟dom; vue中的虚拟dom叫VNode;
vue中封装了一个VNode类，这个类就是虚拟DOM
他和diff算法一起搭配，性能很好，减少重绘和回流
vue的优点？ 
	原生js操作dom一个元素列表，渲染列表时，会删除所有的列表后，重新增加元素到页面上； vue通过diff算法，会找到那个被修改的元素，只重新渲染那一个元素
```

##### diff算法

```javascript
diff算法是一种通过同层的树节点进行比较的高效算法
特点：
	1.比较只会在同层级进行，不会跨层级比较
    2.在diff比较的过程中，循环从两边向中间比较
当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁
通过isSameVnode进行判断，相同则调用patchVnode方法
patchVnode做了以下操作：
找到对应的真实dom，称为el
如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点
如果oldVnode有子节点而VNode没有，则删除el子节点
如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el
如果两者都有子节点，则执行updateChildren函数比较子节点
updateChildren主要做了以下操作：
设置新旧VNode的头尾指针
新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作
```

##### axios

```javascript
定义：一个轻量的http客户端 基于XHR执行Http 支持Promise 支持浏览器和Node.js
特性：
	1.从浏览器中创建XHR
    2.从node.js创建http请求
	3.支持Promise API
    4.拦截 请求和响应
    5.转换请求数据和相应数据
    6.取消请求
    7.自动转换JSON数据
    8.服务端支持防御XSRF
封装
	请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
    状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好
    请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便
    请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问
    响应拦截器： 这块就是根据 后端返回来的状态码判定执行不同业务

```

##### SSR

```javascript
解决了：
	1.SEO：搜索引擎优先爬取页面HTML结构，使用时，服务端已经生成了和业务相关联的HTML
    2.首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图
缺点：
	1.复杂度提升
    2.库的支持性，代码兼容
    3.性能问题
    	1>每个请求都是多个实例创建，不然会污染，消耗变得很大
		2>缓存node serve 、nginx判断当前用户有没有过期，如果没过期就缓存
        3>降级：监控CPU 内存占用过多，就spa，但会单个的壳
    4.服务器负载变大，相当于前后端分离服务器只需要提供静态资源来说，服务器负载更大
实现：
	对于同构开发，使用webpack打包，我们要解决：服务端首屏渲染和客户端激活
小结：
	使用SSR不存在单例模式，每次用户请求都会创建新的实例
    实现SSR需要实现服务端首屏渲染和客户端激活
    服务端异步获取数据可以分为首屏异步获取和切换组件获取
    	首屏异步获取数据，在服务端渲染的时候就应该已经完成
        切换组件通过mixin混入，在beforeMount钩子完成数据获取
```

##### Vue项目的目录结构

```javascript
划分原则：
	文件夹和文件夹内部文件的语义一致性
    单一入口/出口
	就近原则，紧耦合的文件应放到一起，且应以相对路径引用
    公共的文件应该以绝对路径方式从根目录引用
    /src外的文件不应被引入
单页面目录结构
project
│  .browserslistrc
│  .env.production
│  .eslintrc.js
│  .gitignore
│  babel.config.js
│  package-lock.json
│  package.json
│  README.md
│  vue.config.js
│  yarn-error.log
│  yarn.lock
│
├─public
│      favicon.ico
│      index.html
│
|-- src
    |-- components
        |-- input
            |-- index.js
            |-- index.module.scss
    |-- pages
        |-- seller
            |-- components
                |-- input
                    |-- index.js
                    |-- index.module.scss
            |-- reducer.js
            |-- saga.js
            |-- index.js
            |-- index.module.scss
        |-- buyer
            |-- index.js
        |-- index.js
```

##### Vue权限管理

```javascript
前端权限控制：
	接口权限：接口权限一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登陆页面重新进行登录
    路由权限控制：
    	1.初始化即挂载全部路由，且在路由上标记相应的权限信息，每次路由跳转前做校验
    	缺点：
        	1.加载所有的路由，如果路由很多，而用户并不是所有的权限能访问，对性能有影响
            2.全局路由守卫里，每次路由跳转都要做权限判断
            3.菜单信息写死在前端，要改个显示文字或权限，需要重新编译
            4.菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息而且路由不一定作为菜单显示，还要多加字段进行标识
        2.初始化的时候先挂载不需要权限控制的路由，登录后，获取用户的权限信息，然后筛选有权限的路由，在全局路由守卫里进行调用addRoutes添加路由
        缺点：
        	1.全局路由守卫里，每次路由跳转都要做判断
            2.菜单信息写死在前端，要改个显示文字或权限，需要重新编译
            3.菜单跟路由耦合在一起，定义路由的时候还要添加菜单显示标题，图标，而且路由不一定作为菜单显示，还要多加字段进行标识
	菜单权限：
    	1.菜单路由分离，有后端返回。前端定义路由信息，全局路由守卫里做判断
        缺点：
        	1.菜单需要与路由做一一对应，前段添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用
            2.全局路由守卫里，每次路由跳转都要做判断
        2.菜单和路由都有后端返回
        缺点：
        	1.全局路由守卫里，每次路由跳转都要做判断
            2.前后端的配合要求更高
```

##### 跨域

```javascript
跨域的本质是浏览器基于同源策略的一种安全手段
同源策略：一种约定，浏览器最核心也是最基本的安全功能
		协议相同  主机相同  端口相同
解决跨域：
	1.JSONP
    2.CORS
    	是一个系统，它由一系列传输的HTTp头组成，这些http头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应
    3.Proxy
    	代理(网络代理)是一种特殊的网络服务，允许一个客户端通过这个服务与另一个网络终端(服务器)进行非直接的连接。
        1.如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象
		2.还可通过服务端实现代理请求转发
        3.通过配置nginx实现代理
```

##### 项目部署

```javascript
如何部署
	前后端分离开发模式下，前后端是独立部署的，前端只需要将最后的构建物上传至目标服务器的web容器指定的静态目录下即可
```

##### 处理项目中的错误

```javascript
后端接口错误
	通过axios的interceptor实现网络请求的response先进性一层拦截
代码逻辑问题
小结：
	handleError在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法，在遍历调用完所有 errorCaptured 方法或 errorCaptured 方法有报错时，调用 globalHandleError 方法
	globalHandleError 调用全局的 errorHandler 方法，再通过logError判断环境输出错误信息
	invokeWithErrorHandling更好的处理异步错误信息
	logError判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误
```

